HERE IS SOME PROBLEM'S I HAVE DONE TO LEARN DATA STUCTURES and SOME ALGORITHMS

### What I Learned
This codebase is a collection of implementations and examples that helped me understand the fundamentals of data structures and algorithms. It includes:
- How to implement and manipulate various data structures like linked lists, trees, graphs, stacks, queues, and hash tables.
- The importance of time and space complexity in choosing the right data structure or algorithm.
- Practical applications of recursion, sorting algorithms, and traversal techniques.

### Implementations and Their Usefulness

#### Linked Lists
- **Single Linked List**: Operations like adding/removing nodes, searching, and reversing. Useful for dynamic memory allocation and scenarios where frequent insertions/deletions are required.
- **Double Linked List**: Adds bidirectional traversal, making it suitable for undo/redo functionality in applications.
- **Circular Linked List**: Efficient for scenarios like round-robin scheduling.

#### Trees
- **Binary Search Tree (BST)**: Efficient for searching, insertion, and deletion operations. Applications include databases and file systems.
- **Heap**: Max-heap implementation for priority queues and heap sort for efficient sorting.
- **Trie**: Useful for autocomplete, spell-checking, and prefix-based searches.
- **Tree Utilities**: Functions to check completeness and compare trees, which are helpful in validating tree structures.

#### Graphs
- **Adjacency List Representation**: Efficient storage and traversal using DFS and BFS. Useful in network analysis, pathfinding, and social network connections.

#### Stacks
- Implemented using arrays, objects, and linked lists. Useful for managing function calls, undo operations, and expression evaluation.

#### Queues
- Implemented using arrays, objects, and linked lists. Applications include task scheduling, buffering, and breadth-first search.

#### Hash Tables
- Basic hash table implementation for fast key-value lookups. Useful in caching, database indexing, and associative arrays.

#### Sorting Algorithms
- Implementations of selection sort, bubble sort, insertion sort, quick sort, and merge sort. These are foundational for understanding how data can be organized efficiently.

#### Recursion
- Examples include factorial, Fibonacci sequence, binary search, and palindrome generation. Recursion is a powerful tool for solving problems that can be broken into smaller subproblems.

### How It Is Useful
- **Problem-Solving**: These implementations provide a strong foundation for solving real-world problems.
- **Interview Preparation**: Covers commonly asked data structure and algorithm questions.
- **Code Reusability**: Modular implementations can be reused in various projects.
- **Performance Optimization**: Understanding time and space complexity helps in writing efficient code.
